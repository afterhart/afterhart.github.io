<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AFTERHART — Main</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>


  <aside class="sidebar" aria-label="Primary">
    <div class="brand">AFTERHART</div>

    <nav class="nav" aria-label="Main navigation">
      <ul>
        <li><a href="index.html" data-page="main">Main</a></li>
        <li><a href="catalog.html" data-page="catalog">Catalog</a></li>
        <li><a href="gallery.html" data-page="gallery">Gallery</a></li>
        <li><a href="bio.html" data-page="bio">Bio</a></li>
      </ul>
    </nav>
  </aside>

  <main id="main" class="main" role="main" tabindex="-1">
    <section class="hero" aria-hidden="false">
      <!-- Видео-плеер — muted, autoplay, loop, playsinline -->
      <video id="hero-video" class="hero-video" autoplay muted loop playsinline preload="auto" poster="poster.jpg" aria-label="Background video">
        <source src="intro1.mp4" type="video/mp4" />
        Your browser does not support the video tag.
      </video>
    </section>

    <!-- Ниже — каталог/карточки -->
    <section class="catalog" aria-label="Catalog">
      <div class="grid">
        <article class="item">
          <a href="look1.html">
            <img src="look1.jpg" alt="ANGEL I" loading="lazy" />
            <p>ANGEL I</p>
          </a>
        </article>
        <article class="item">
          <a href="look2.html">
            <img src="look2.jpg" alt="MATTHEW 16:19" loading="lazy" />
            <p>MATTHEW 16:19</p>
          </a>
        </article>
        <article class="item">
          <a href="look3.html">
            <img src="look3.jpg" alt="KETA JACKET" loading="lazy" />
            <p>KETA JACKET</p>
          </a>
        </article>
        <article class="item">
          <a href="look4.html">
            <img src="look4.jpg" alt="RUST BELT" loading="lazy" />
            <p>RUST BELT</p>
          </a>
        </article>
      </div>
    </section>
  </main>

<script>
(function () {
  const links = document.querySelectorAll('.nav a[data-page]');
  const setActive = (page) => {
    links.forEach(a => {
      const isActive = a.dataset.page === page;
      a.classList.toggle('active', isActive);
      if (isActive) a.setAttribute('aria-current', 'page');
      else a.removeAttribute('aria-current');
    });
  };

  const mapPathToPage = (p) => {
    if (!p || p === '/' || p === '/index.html') return 'main';
    const name = p.split('/').pop().toLowerCase();
    if (name === 'index.html' || name === '') return 'main';
    return name.replace('.html', '');
  };
  setActive(mapPathToPage(window.location.pathname));
  links.forEach(a => a.addEventListener('click', () => setActive(a.dataset.page)));

  const hero = document.querySelector('.hero');
  const grid = document.querySelector('.grid');
  if (!hero || !grid) return;

  let gridItems = Array.from(grid.querySelectorAll('.item'));
  let firstRowItems = [];

  // Ждём загрузки всех изображений внутри grid, чтобы расчёты были корректными
  const waitForGridImages = () => {
    const imgs = Array.from(grid.querySelectorAll('img'));
    const promises = imgs.map(img => {
      if (img.complete) return Promise.resolve();
      return new Promise(resolve => {
        img.addEventListener('load', resolve, { once: true });
        img.addEventListener('error', resolve, { once: true });
      });
    });
    return Promise.all(promises);
  };

  const EPS = 3; // допуск в px для сравнения top

  const updateFirstRowItems = () => {
    gridItems = Array.from(grid.querySelectorAll('.item'));
    if (!gridItems.length) { firstRowItems = []; return; }
    const rects = gridItems.map(it => it.getBoundingClientRect());
    const tops = rects.map(r => r.top);
    const minTop = Math.min(...tops);
    firstRowItems = gridItems.filter((it, i) => Math.abs(rects[i].top - minTop) <= EPS);
    // debug
    console.debug('firstRow count=', firstRowItems.length);
  };

  const isElementFullyVisible = (el) => {
    const r = el.getBoundingClientRect();
    const vh = window.innerHeight || document.documentElement.clientHeight;
    return r.top >= 0 && r.bottom <= vh;
  };

  const isFirstRowFullyVisible = () => {
    if (!firstRowItems.length) return false;
    const rects = firstRowItems.map(el => el.getBoundingClientRect());
    const top = Math.min(...rects.map(r => r.top));
    const bottom = Math.max(...rects.map(r => r.bottom));
    const vh = window.innerHeight || document.documentElement.clientHeight;
    // debug
    console.debug('firstRow top,bottom,vh=', Math.round(top), Math.round(bottom), vh);
    return top >= 0 && bottom <= vh;
  };

  // Инициализируем: ждём загрузки картинок, затем считаем первую строку и запускаем обработчики
  waitForGridImages().then(() => {
    updateFirstRowItems();
    // начальная проверка
    requestAnimationFrame(() => {
      if (isFirstRowFullyVisible()) setActive('shop');
      else if (isElementFullyVisible(hero)) setActive('main');
    });
  });

  // при ресайзе пересчитываем первую строку (адаптив меняет количество колонок)
  let resizeTimer;
  const onResize = () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      updateFirstRowItems();
      // и сразу проверим состояние
      if (isFirstRowFullyVisible()) setActive('shop');
      else if (isElementFullyVisible(hero)) setActive('main');
    }, 150);
  };
  window.addEventListener('resize', onResize);

  // Throttled scroll handler через rAF
  let ticking = false;
  const onScroll = () => {
    if (!ticking) {
      requestAnimationFrame(() => {
        // Приоритет: если первая строка полностью видна -> Catalog
        if (isFirstRowFullyVisible()) {
          setActive('shop');
        } else if (isElementFullyVisible(hero)) {
          setActive('main');
        }
        ticking = false;
      });
      ticking = true;
    }
  };
  window.addEventListener('scroll', onScroll, { passive: true });

  // Если динамически добавляете/удаляете элементы, пересчитываем через MutationObserver
  const mo = new MutationObserver(() => {
    // подождём чуть-чуть чтобы DOM произвёл рендер
    setTimeout(() => {
      waitForGridImages().then(updateFirstRowItems);
    }, 60);
  });
  mo.observe(grid, { childList: true, subtree: true });

  // очистка при выходе (опционально)
  // window.addEventListener('beforeunload', () => mo.disconnect());
})();
</script>

</body>
</html>







































